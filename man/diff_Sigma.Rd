% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/differencing.R
\name{diff_Sigma}
\alias{diff_Sigma}
\alias{undiff_Sigma}
\alias{delta}
\title{Difference and undifference error term covariance matrix}
\usage{
diff_Sigma(Sigma, diff_alt = 1)

undiff_Sigma(Sigma_diff, diff_alt = 1)

delta(diff_alt, J)
}
\arguments{
\item{Sigma}{A \code{matrix} of dimension \code{J} x \code{J}, the error term covariance
matrix.}

\item{diff_alt}{An \code{integer} from \code{1} to \code{J}, the reference alternative for
utility differencing that maps \code{Sigma} to \code{Sigma_diff}, see
details.
Bydefault, \code{diff_alt = 1}.}

\item{Sigma_diff}{A \code{matrix} of dimension \code{J-1} x \code{J-1}, the differenced error
term covariance matrix.}

\item{J}{An \code{integer}, number of alternatives.}
}
\value{
A \code{matrix}, the differenced (undifferenced) error term covariance
matrix.
}
\description{
These functions difference and undifference the error term covariance matrix
\eqn{\Sigma} with respect to a reference alternative \code{diff_alt}.
}
\section{Difference and undifference error term covariance matrix}{
The probit model equation
\deqn{U_{ntj} = X_{ntj}' \tilde{\beta}_n + \epsilon_{ntj},}
with \eqn{(\epsilon_{nt:}) \sim \text{MVN}_{J} (0,\Sigma)}
is invariant towards the level of utility, hence we take
utility differences with respect to some reference alternative \eqn{k}
(also denoted by \code{diff_alt}). The resulting error term differences again
are multivariate normally distributed with mean \eqn{0} and transformed
covariance matrix \eqn{\tilde{\Sigma}}, also denoted by \code{Sigma_diff}.

For differencing:
\deqn{\tilde{\Sigma} = \Delta_k \Sigma \Delta_k',}
where \eqn{\Delta_k} is a difference operator that depends on the reference
alternative \eqn{k}, see below.

The "undifferenced" covariance matrix \eqn{\Sigma} cannot be uniquely
computed from \eqn{\tilde{\Sigma}}.
For one solution, we add a column and a row of zeros
at column and row number \eqn{k} to \eqn{\tilde{\Sigma}}, respectively, and
add \eqn{1} to each matrix entry to make the result a proper covariance
matrix.
}

\section{Difference operator}{
The matrix \eqn{\Delta_k} in equation
\deqn{\tilde{\Sigma} = \Delta_k \Sigma \Delta_k'}
is a matrix of dimension \eqn{(J-1)\times J}.
It is the unit matrix of dimension \eqn{J} without row \eqn{k} and with
\eqn{-1}s in column \eqn{k}.
It can be computed with \code{delta(diff_alt, J)}, where \code{diff_alt}
denotes \eqn{k}.
}

\examples{
J <- 3
diff_alt <- 2
delta(diff_alt, J)
(Sigma0 <- RprobitB:::sample_covariance_matrix(dim = J))
(Sigma_diff0 <- RprobitB:::diff_Sigma(Sigma0, diff_alt = diff_alt))
(Sigma1 <- RprobitB:::undiff_Sigma(Sigma_diff0, diff_alt = diff_alt))
(Sigma_diff1 <- RprobitB:::diff_Sigma(Sigma1, diff_alt = diff_alt))
all.equal(Sigma_diff0, Sigma_diff1)

}
\seealso{
\code{\link[=is_covariance_matrix]{is_covariance_matrix()}} to check whether a matrix is a covariance matrix
}
\keyword{internal}
