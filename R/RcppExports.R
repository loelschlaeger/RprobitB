# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Euclidean distance
#' @description
#' This function computes the euclidean distance between two vectors.
#' @param a
#' A numeric vector.
#' @param b
#' Another numeric vector of the same length as \code{a}.
#' @return
#' The euclidean distance.
#' @export
#' @keywords
#' utils
#'
euc_dist <- function(a, b) {
    .Call(`_RprobitB_euc_dist`, a, b)
}

#' Density of multivariate normal distribution
#' @description
#' This function computes the density of a multivariate normal distribution.
#' @param x
#' A quantile vector of length \code{n}.
#' @param mean
#' The mean vector of length \code{n}.
#' @param Sigma
#' The covariance matrix of dimension \code{n} x \code{n}.
#' @param log
#' A boolean, if \code{TRUE} the logarithm of the density value is returned.
#' @return
#' A density value.
#' @export
#' @keywords
#' dist
#'
dmvnorm <- function(x, mean, Sigma, log = FALSE) {
    .Call(`_RprobitB_dmvnorm`, x, mean, Sigma, log)
}

#' Draw from Dirichlet distribution
#' @description
#' Function to draw from a Dirichlet distribution.
#' @param alpha
#' A vector, the concentration parameter.
#' @return
#' A vector, the sample from the Dirichlet distribution.
#' @export
#' @keywords
#' dist
#'
rdirichlet <- function(alpha) {
    .Call(`_RprobitB_rdirichlet`, alpha)
}

#' Draw from Wishart distribution
#' @description
#' This function draws from a Wishart and inverted Wishart distribution.
#' @param nu
#' A double, the degrees of freedom.
#' @param V
#' A matrix, the scale matrix.
#' @return
#' A list, the draws from the Wishart (W), inverted Wishart (IW), and
#' corresponding Cholesky decompositions (C and CI).
#' @export
#' @keywords
#' dist
#'
rwishart <- function(nu, V) {
    .Call(`_RprobitB_rwishart`, nu, V)
}

#' Draw from multivariate normal distribution
#' @description
#' This function draws from a multivariate normal distribution.
#' @param mu
#' The mean vector of length \code{n}.
#' @param Sigma
#' The covariance matrix of dimension \code{n} x \code{n}.
#' @return
#' A numeric vector of length \code{n}.
#' @export
#' @keywords
#' dist
#'
rmvnorm <- function(mu, Sigma) {
    .Call(`_RprobitB_rmvnorm`, mu, Sigma)
}

#' Update class weight vector
#' @description
#' This function updates the class weight vector by drawing from its posterior.
#' @param delta
#' The concentration parameter of length 1 of the Dirichlet prior for \code{s}.
#' @param m
#' The vector of current class sizes.
#' @return
#' A draw from the Dirichlet posterior for \code{s}.
#' @export
#' @keywords
#' posterior
#'
update_s <- function(delta, m) {
    .Call(`_RprobitB_update_s`, delta, m)
}

#' Update class allocation vector
#' @description
#' This function updates the class allocation vector independently for all observations
#' by drawing from its conditional distribution.
#' @inheritParams RprobitB_parameter
#' @return
#' An updated class allocation vector.
#' @export
#' @keywords
#' posterior
#'
update_z <- function(s, beta, b, Omega) {
    .Call(`_RprobitB_update_z`, s, beta, b, Omega)
}

#' Gibbs sampler.
#' @description
#' This function performs Gibbs sampling for the RprobitB package.
#' @inheritParams mcmc
#' @inheritParams RprobitB_data
#' @param sufficient_statistics
#' The output of \code{\link{sufficient_statistics}}.
#' @param init
#' The output of \code{\link{set_initial_gibbs_values}}.
#' @return
#' A list of Gibbs samples for \code{Sigma}, \code{alpha} (if \code{P_f>0})
#' and \code{s}, \code{b}, \code{Omega} and a vector of classifications
#' (if \code{P_r>0}).
#' @keywords
#' internal
#'
gibbs_sampling <- function(R, B, print_progress, N, J, P_f, P_r, latent_classes, sufficient_statistics, prior, init) {
    .Call(`_RprobitB_gibbs_sampling`, R, B, print_progress, N, J, P_f, P_r, latent_classes, sufficient_statistics, prior, init)
}

#' Draw from truncated normal
#' @description
#' This function draws from a truncated univariate normal distribution.
#' @param mu
#' The mean.
#' @param sig
#' The standard deviation.
#' @param trunpt
#' The truncation point.
#' @param above
#' A boolean, if \code{TRUE} truncate from above, otherwise from below.
#' @return
#' A numeric value.
#' @export
#' @keywords
#' dist
#'
rtnorm <- function(mu, sig, trunpt, above) {
    .Call(`_RprobitB_rtnorm`, mu, sig, trunpt, above)
}

