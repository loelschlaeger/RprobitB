---
title: "Choice data"
author: "Lennart OelschlÃ¤ger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Choice data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette explains how to handle choice data in RprobitB. We use the [Train dataset from the mlogit package](https://cran.r-project.org/package=mlogit) for illustration.

```{r setup}
library(RprobitB)
```


## Characteristics and requirements of choice data

Choice data basically consists of

1. an identifier for each decider and optionally for each choice situation (the latter is only relevant in the panel context),

2. the choices in each choice situation,

3. alternative and decider specific covariates for each choice situation.


Therefore, RprobitB requests the following requirements to provided choice data:

1. It must be of class `data.frame`.

2. It must be in "wide" format, i.e. each row represents one choice occasion.

3. It must contain a column with unique identifier for each decision maker. 

4. It can contain a column with identifier for each choice situation, which must be unique given the decider. If this information is missing, these identifier are generated by the appearance of the choices in the data set. 

5. It can contain a column with the observed choices. Such a column is required for model fitting but not for prediction.

6. It must contain columns for the values of each alternative specific covariate for each alternative and for each decider specific covariate.


### Example

We can check that the Train dataset[^1] fulfills these requirements:

```{r overview Train data}
data("Train", package = "mlogit")
str(Train)
```

It is a data frame, each row represents one choice occasion, the columns `id` and `choiceid` identify the deciders and the choice occasions, respectively. The column `choice` gives the observed choices. We see four alternative-specific covariates, namely `price`, `time`, `change` and `comfort`. There values are given for each alternative.

[^1:] The dataset contains 2929 stated choices by 235 Dutch individuals deciding between two train trip options based on the price, the travel time, the level of comfort, and the number of changes. 


## Specify the model formula

We have to tell RprobitB which covariates we want to include in our model. This is done by specifying a `formula` object, which we call `form` in the following.

The structure of `form` is `choice ~ A | B | C`, where

- `choice` is the explanatory variable (the discrete choice we aim to explain),

- `A` are alternative and choice situation specific covariates with a generic coefficient (we call them covariates of type 1),

- `B` are choice situation specific covariates with alternative specific coefficients (we call them covariates of type 2),

- and `C` are alternative and choice situation specific covariates with
alternative specific coefficients (we call them covariates of type 3).


Specifying `form` must be consistent with the following rules:

- By default, alternative specific constants (ASCs) are added to the model[^2]. They can be removed by adding `+ 0` in the second spot, e.g. `choice ~ A | B + 0`.

- To exclude covariates of the backmost categories, use either `0`, e.g. `choice ~ A | B | 0` or just leave this part out and write `choice ~ A | B `. However, to exclude covariates of front categories, we have to use `0`, e.g. `choice ~ 0 | B`. 

- To include more than one covariate of the same category, use `+`, e.g. `choice ~ A1 + A2 | B`.

- If we don't want to include any covariates of the second category but we want to estimate alternative specific constants, add `1` in the second spot, e.g. `choice ~ A | 1`. The expression `choice ~ A | 0` is interpreted as no covariates of the second category and no alternative specific constants.

To have random effects for specific variables, we need to define a character vector `re` of the corresponding variable names. To have random effects for the alternative specific constants, include `"ASC"` in `re`.


RprobitB provides the function `check_form(form, re)` which can be used to check if `form` and `re` are correctly interpreted.

[^2]: Duo to identifiability, we cannot estimate ASCs for all the alternatives. Therefore, they are added for all except for the last alternative.


### Example

We specify a model formula for the Train dataset. Say we want to include all the covariates `price`, `time`, `comfort` and `change`, which are all alternative specific, so either of type 1 or type 3. The difference between type 1 and type 3 is that in the former case we would estimate a generic coefficient (i.e. a coefficient that is constant across alternatives), whereas in the latter case we would estimate alternative specific coefficients. 

Deciding between type 1 and type 3 for these covariates belongs into the topic of model selection, for which we provide a separate vignette. For now, we go with type 1 for all covariates and add ASCs: 

```{r train formula}
form = choice ~ price + time + comfort + change | 1
```

Additionally, we specify random effects for `price` and `time` because we typically expect heterogeneity here:

```{r train re}
re = c("price","time")
```

The formula check verifies that our specification is correctly interpreted by RprobitB:

```{r check form}
check_form(form = form, re = re)
```


## The `prepare_data()` function in RprobitB

Before model estimation with RprobitB, any empirical choice dataset `choice_data`  must go through the `prepare_data()` function:

```{r, eval = FALSE}
data = prepare_data(form = form, choice_data = choice_data)
```

The function performs compatibility checks and data transformations and returns an object of class `RprobitB_data` that can be fed into the estimation routine. The function has the following optional arguments:

- `alternatives`: We may not want to consider all alternatives in `choice_data`. In that case, we can specify a character vector `alternatives` with selected names of alternatives.

- `re`: The character vector of variable names of `form` with random effects.

- `id`: A character, the name of the column in `choice_data` that contains a unique identifier for each decision maker. The default is `"id"`. 

- `idc`: A character, the name of the column in `choice_data` that contains a unique identifier for each choice situation given the decision maker. Per default, these identifier are generated by the appearance of the choices in the data set.  

- `standardize`: A character vector of variable names of `form` that get standardized, see [below](#standardize-covariates).

- `test_prob`: A numeric between 0 and 1, specifying the proportion of a test dataset for model checking, see [below](#split-dataset).


### Example

Let's prepare the Train dataset for estimation with our previous specification of `form` and `re`:

```{r prepare Train}
data = prepare_data(form = form, choice_data = Train, re = re)
```

The `summary` function gives an overview over the data:

```{r summary Train}
summary(data)
```


## Simulate choice data in RprobitB using the `simulate_choices()` function

If no empirical choice data is at hand or we want to conduct a simulation experiment, RprobitB provides the function `simulate_choices` that (literally) simulates choices. Say we want to simulate the choices of `N` deciders in `T` choice occasions[^3] among `J` alternatives from a model formulation `form`, we have to call

```{r, eval = FALSE}
data = simulate(form = form, N = N, T = T, J = J)
```

The function `simulate()` has the following optional arguments:

- `re`: The character vector of variable names of `form` with random effects.

- `alternatives`: A character vector of length `J` with the names of the choice alternatives.

- `distr`: A named list of number generation functions from which the covariates are drawn. Each element of `distr` must be of the form `"cov" = list("name" = "<name of the number generation function>", ...)`, where `cov` is the name of the covariate[^4] and `...` are required parameters for the number generation function. Covariates for which no distribution is specified are drawn from a standard normal distribution. Possible number generation functions are

  - functions of the type `r*` from base R (e.g. `rnorm`) where all required parameters (except for `n`) must be specified,

  - the function `sample`, where all required parameters except for `size`) must be specified.

- `standardize`: A character vector of variable names of `form` that get standardized, see [below](#standardize-covariates).

- `test_prob`: A numeric between 0 and 1, specifying the proportion of a test dataset for model checking, see [below](#split-dataset).

- `seed`: Set a seed for the simulation.

We can specify true parameter values by adding values for

- `alpha`, the fixed coefficient vector,
  
- `C`, the number (greater or equal 1) of latent classes of decision, makers
  
- `s`, the vector of class weights,
  
- `b`, the matrix of class means as columns,
  
- `Omega`, the matrix of class covariance matrices as columns,
  
- `Sigma`, the differenced error term covariance matrix,
  
- `Sigma_full`, the full error term covariance matrix.

[^3]: `T` can be either a positive number, representing a fixed number of choice occasions for each decision maker, or a vector of length `N`, i.e. a decision maker specific number of choice occasions.

[^4]: For a covariate `cov` of type 1 or 3, you can either choose `"name" = cov` (to draw the covariate for all alternatives from the same distribution) or `"name" = cov_alternative` (to draw the covariate for a specific alternative from a specific distribution).


### Example

Say we want to replicate the Train dataset...


## Standardize covariates

Both `prepare_data()` and `simulate_choices()` have the optional input `standardize`, which is a character vector of names of covariates that get standardized, i.e. normalize to mean 0 and standard deviation 1. If `standardize = "all"`, all covariates get standardized.

Covariates of type 1 or 3 have to be addressed by `<covariate>_<alternative>`.

If `standardize = "all"`, all covariates get standardized.


## Split dataset

We can split the dataset...
